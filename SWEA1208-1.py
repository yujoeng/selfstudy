# 카운팅 배열을 쓰는 풀이

T = 10  # 테스트케이스 수가 10개로 고정, 따로 입력을 받지 않음.

for tc in range(1, T + 1):
    dump_cnt = int(input())  # 덤프 횟수
    data = list(map(int, input().split()))  # 상자 높이 배열 (100개)

    # 카운팅 배열
    # - 상자의 높이를 카운팅하면, 카운팅 배열에서 0이 아닌 값을 찾으면 됨
    #  - 가장 왼쪽에 있는 값이 최소값의 개수
    #  - 가장 오른쪽에 있는 값이 최대값의 개수

    # 카운팅 배열 만들기
    cnt = [0] * 101  # 인덱스 최댓값이 100이므로 101개 배열을 만든다.
    # 높이의 갯수 세기
    for num in data:  # 높이를 순회
        cnt[num] += 1

    # 덤프 횟수만큼 덤프하기
    for _ in range(dump_cnt):
        lft = 0  # 왼쪽 인덱스 0에서부터 출발
        rgt = 100  # 오른쪽 인덱스는 100에서부터 출발

        """

        lft = 0부터 시작해서 오른쪽으로 가면서 0이 아닌 첫번째 수(최소값)를 찾고 싶음
        목표 : lft != 0 => 반복 종료
        원치 않는 상태: lft == 0 => while문 조건에 넣기

        """

        while cnt[lft] == 0:  # 갯수가 0이면(원치 않는 상황)
            # cnt[lft] == 0 : 반복 돌기
            lft += 1  # 오른쪽으로 이동
        # 언제 반복이 종료?
        # cnt[lft] != 0이 되는 첫번째 순간에 반복이 종료가 됨.

        # while 문을 빠져나왔다는 것은 cnt[lft] != 0인 첫번째 상황을 만난 것임.
        # lft : 높이의 최솟값. cnt[lft]: 최소값의 개수

        while cnt[rgt] == 0:  # 갯수가 0이면
            rgt -= 1  # 왼쪽으로 이동

        # rgt: 높이의 최댓값

        # 덤프 수행
        cnt[lft] -= 1
        cnt[rgt] -= 1
        cnt[lft + 1] += 1
        cnt[rgt - 1] += 1

    # 모든 덤프 완료
    # 덤프 완료 후에 다시 최대, 최소를 찾는다.
    lft = 0
    rgt = 100

    while cnt[lft] == 0:
        lft += 1
    while cnt[rgt] == 0:
        rgt -= 1

    print(f"#{tc} {rgt - lft}")